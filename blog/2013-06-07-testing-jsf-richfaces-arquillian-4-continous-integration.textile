---
layout: post
title: "Testing JSF and RichFaces with Arquillian - Part IV - Running in Continuous Integration"
tags: [ "arquillian", "warp", "graphene", "jsf", "richfaces", "series", "testing-jsf" ]
---

Once you are prepared for developing your tests, you should also think about how and where to run them.

The last part of this series is dedicated to running tests in continuous integration.

h2. Integration Testing First Principle

I believe that the way forward is to first focus on verifying correctness, and then later paying attention to making it faster and more efficient.

There are always options on how to improve the execution time.

h3. Extensive Coverage in Continuous Integration

Once the test suite is written, we need to run it continuously to ensure that the code is compatible with all supported browsers and containers. That's pretty simple task when you use Arquillian configuration.

h4. Managing Integration Environment

As opposed to development time (when we want to achieve fast turnaround), in continuous integration we are seeking different goals - the ability to control a complete tested environment from our build system.


h5. Managed Containers

Once we switch tests to run in continuous integration, we will leverage Arquillian managed containers to bootstrap a container and manage it's lifecycle.

h5. Managed Browsers

Similarly, the Drone extension allows to instantiate browsers directly, without the need to manually start the Selenium Server.

This way you can simply switch from developing remotely during development, to run in managed containers during continuous integration.

Selenium itself offers to test against a variety of browsers: Firefox, Chrome, Internet Explorer, Opera, Safari, Android, iPhone/iPad, HtmlUnit, PhantomJS.

Ideally, you should setup your tests to run your tests against each of the browsers you support.

h4. Browsers in a Cloud - SauceLabs

In order to use real browsers, it is usually necessary to invest in your test infrastructure.

Fortunately even this initial infrastructure investment can be avoided by using cloud browser-providers like SauceLabs.

Drone supports this out-sourcing and simplifies it to a simple configuration switch.

h3. Fast Feedback for Continuous Development

Once we have configured tests to be run against real implementations while following "Integration Testing First Principle", it is time to make it really useful by configuring it to deliver fast feedback.

In order to guard against regressions which could be introduced by code changes, we need to run continuous integration after each commit.

This would be very resource-consuming since we have so far written just real browser tests.

h4. Mock Browser - PhantomJS

Fortunately there are browsers which can run WebDriver-based tests headlessly (without a screen output), without any external dependencies and faster then real browsers.

And that's where Drone shines again: you can simply switch from real browsers to a mocked browser.

There are currently two mocked browsers with WebDriver API:

* HtmlUnit - an artifical engine based on Rhino
* PhantomJS - a headless fork of QtWebKit (similar to Chrome/V8 engine)

We favor PhantomJS, since it will give us ability to debug the test failures easily.

div(alert alert-info). Note: that you can get really precise results (near to a real browser's implementation) when you use the right mocked browser implementation, such as PhantomJS which is near to the Chrome implementation.

h4. Test Categories

Since our application may require a variety of tests, some of them can be identified as not so important to be run on a per commit basis.

We can select the tests which we want to run everytime - after each commit - and annotate them with the JUnit category: @Categories(Smoke.class).

On our post-commit continuous integration job, we will run all the smoke tests on a PhantomJS browser.

h2. Conclusion

When we put all the pieces together, we have greatness from both worlds - we are testing on real browsers and real containers during full-fledge testing sessions, but we also get feedback as-fast-as-possible with our integration tests running headlessly.